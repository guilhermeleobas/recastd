
# coding: utf-8

from __future__ import unicode_literals

import sys
import os

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
rcParams.update({'figure.autolayout': True})
import matplotlib
import pandas as pd
import toolz

import classifier

from matplotlib import rc
rc('font',**{'family':'sans-serif','sans-serif':['Helvetica']})
# matplotlib.rc('font', family='Arial')
## for Palatino and other serif fonts use:
# rc('font',**{'family':'serif','serif':['Palatino']})
rc('text', usetex=True)


from toolz.curried import map
from toolz.functoolz import pipe
from toolz.itertoolz import unique


trace = sys.argv[1]


recast_path = './recast_class/' + trace
recastd_path = './recastd_class/' + trace


# In[29]:

p_rnd = [1e-6, 1e-5, 1e-4, 1e-3,]


# In[30]:

def build_graph(fname):  
    return nx.parse_edgelist (
        open(fname, 'r'),
        nodetype=int, 
        data=(('class', int),),
        create_using=nx.Graph()
    )


# In[ ]:




# This reads the files generated by *offline* recast 

# base3 is the graph with the class assigned by recast when using $p_{rnd} = 10^{-3}$

# In[32]:

base3 = build_graph(recast_path + os.sep + '0.001.txt')   # 10^-3
base4 = build_graph(recast_path + os.sep + '0.0001.txt')  # 10^-4
base5 = build_graph(recast_path + os.sep + '1e-05.txt')   # ...
base6 = build_graph(recast_path + os.sep + '1e-06.txt')


# List every file in recastd directory. The first number is the node id and the second is the $p_{rnd}$ value used
# ![image.png](attachment:image.png)

# See **gen_edgelist** to see how I generate these files

# In[34]:

recastd_files = list(pipe(
    os.listdir(recastd_path),
    map(lambda x: x.strip('.txt').split('_')[0]),
    unique,
))


# In[35]:

# acertos = dict.fromkeys(map(str, p_rnd), 0)
# erros = dict.fromkeys(map(str, p_rnd), 0)


# classifier*x* is a dict (edge -> class) that stores the class given by recastd for an edge

# For instance, $classifier3[(1, 2)]$ = $\textbf{friends}$ means that recast**d** assigned the class **friends** for the pair $(1, 2)$ in the ego graph induced by $1$ when using $p_{rnd} = 10^{-3}$

# It's valid to say that the classification is not symmetric. The class of $(x, y)$ is not always the same as $(y, x)$. This is because every node creates it's own ego graph. 

# In[36]:

classifier3 = dict()
classifier4 = dict()
classifier5 = dict()
classifier6 = dict()


# For every edge in each graph, store the class for that edge according to the $p_{rnd}$ value used.

# In[37]:

def map_values(node, cls, graph):
    for j in graph.neighbors_iter(node):
        cls[(node, j)] = graph.get_edge_data(node, j)['class']


# In[38]:

for r in recastd_files:
    graph3 = build_graph(recastd_path + os.sep + r + '_0.001.txt')
    graph4 = build_graph(recastd_path + os.sep + r + '_0.0001.txt')
    graph5 = build_graph(recastd_path + os.sep + r + '_1e-05.txt')
    graph6 = build_graph(recastd_path + os.sep + r + '_1e-06.txt')

    map_values (int(r), classifier3, graph3)
    map_values (int(r), classifier4, graph4)
    map_values (int(r), classifier5, graph5)
    map_values (int(r), classifier6, graph6)


# In[ ]:




# In[ ]:




# In[ ]:




# # Optimal Classification

# For every class (friends, bridges, ...) and for every $p_{rnd}$, I compute the number of optimal classifications. 
# 
# A classification is said to be optimal if for a pair of nodes $(x, y)$ the class assigned by *recast* is the same assigned by *recastd* on ego_graph$(x)$ and on ego_graph$(y)$

# In[39]:

def classificacao_otima (cls, base):
    opt = dict()
    opt[classifier.friends] = 0
    opt[classifier.bridges] = 0
    opt[classifier.acquaintance] = 0
    opt[classifier.random] = 0
    
    for (x, y) in cls.iterkeys():
        assert (base.has_edge(x, y))
        c1 = cls[(x, y)]
        c2 = cls[(y, x)]
        if base.get_edge_data(x, y)['class'] == c1 == c2:
            opt[c1] += 1
    return opt


# In[40]:

otimo3 = classificacao_otima (classifier3, base3)
otimo3


# In[42]:

otimo4 = classificacao_otima (classifier4, base4)
otimo4


# In[43]:

otimo5 = classificacao_otima (classifier5, base5)
otimo5


# In[44]:

otimo6 = classificacao_otima (classifier6, base6)
otimo6


# ### pandas analysis

# In[45]:

df = pd.DataFrame.from_dict ({
    '$10^{-3}$': otimo3,
    '$10^{-4}$': otimo4,
    '$10^{-5}$': otimo5,
    '$10^{-6}$': otimo6,
})

df = df.transpose()
df.columns = ['Random', 'Friends', 'Acquaintance', 'Bridges']


# In[46]:

df['sum'] = df.sum(axis=1)
df = df.loc[:, 'Random':'Bridges'].div(df['sum'], axis=0)
df


# In[66]:

ax = df.plot(kind='bar', 
        logy=True, 
        title='Optimal Classification for {}'.format(trace),
        rot=0)

ax.set_ylabel('\%')
ax.set_xlabel('$p_{rnd}$')

fig = ax.get_figure();
fig.savefig('images/' + trace + '/classes/optimal.png')


# From the plot above, we see that most of the optimal classifications are to *random* and *bridges* classes

# This is expected when nodes don't share their graph in an encounter. The reason is that $p_{rnd}$ is calculated in the random counter part of each ego graph and they are pratically the same

# In[ ]:




# ### To where the classes are going?

# In[48]:

classes = {
    'friends': classifier.friends,
    'bridges': classifier.bridges,
    'acquaintance': classifier.acquaintance,
    'random': classifier.random,
}


# In[49]:

def count_classification (cls, base):
    
    def map_classes (c):
        return {
            0: 'random',
            2: 'friends',
            3: 'acquaintance',
            4: 'bridges',
        }[c]
    
    opt = {
        'friends': {k: 0 for k in classes.keys()},
        'bridges': {k: 0 for k in classes.keys()},
        'acquaintance': {k: 0 for k in classes.keys()},
        'random': {k: 0 for k in classes.keys()},
    }
    for (x, y) in cls.iterkeys():
        assert (base.has_edge(x, y))
        
        c0 = map_classes(base.get_edge_data(x, y)['class'])
        c1 = map_classes(cls[(x, y)])
        c2 = map_classes(cls[(y, x)])
        opt[c0][c1] += 1
        opt[c0][c2] += 1
    return opt


# In[ ]:




# In[ ]:




# ##### For each $p_{rnd}$...

# In[50]:

def build_table(classifier, base):
    w = count_classification(classifier, base)
    df = pd.DataFrame.from_dict(w)
    df.columns = ['Recast Acquaintance', 'Recast Bridges', 'Recast Friends', 'Recast Random']
    df = df.transpose()
    df.columns = ['RD Acquaintance', 'RD Bridges', 'RD Friends', 'RD Random']
    
    # taking percentage
    df['sum'] = df.sum(axis=1)
    df = df.loc[:, 'RD Acquaintance':'RD Random'].div(df['sum'], axis=0)
    return df


# ##### for base3

# In[51]:

df3 = build_table(classifier3, base3)


# In[52]:

df3


# In the table above, The first column of each row represents the class assigned by Recast and the header (first row) is the class assigned by **Distributed Recast**. For instance, if an edge $(x, y)$ is marked as *friends* by Recast and *Acquaintance* by Distributed Recast, then we count $+1$ in the table[Recast friends][RD Acquaintance]

# Note that we're are counting the same edge twice $(x, y)$ and $(y, x)$

# In[77]:

ax = df3.plot(kind='bar', 
              title='How classes are divided for ' + trace + ' with $p_{rnd} = 10^{-3}$',
              logy=True, 
              rot=0)

ax.set_xlabel('Recast Class')
ax.set_ylabel('\%')

fig = ax.get_figure();
fig.savefig('images/' + trace + '/classes/classes3.png')


# ##### for base4

# In[54]:

df4 = build_table(classifier4, base4)


# In[55]:

df4


# In[78]:

ax = df4.plot(kind='bar', 
         title='How classes are divided for ' + trace + ' with $p_{rnd} = 10^{-4}$',
         logy=True,
         rot=0)

ax.set_xlabel('Recast Class')
ax.set_ylabel('\%')

fig = ax.get_figure();
fig.savefig('images/' + trace + '/classes/classes4.png')


# ##### for base5

# In[57]:

df5 = build_table(classifier5, base5)


# In[58]:

df5


# In[79]:

ax = df5.plot(kind='bar', 
         title='How classes are divided for ' + trace + ' with $p_{rnd} = 10^{-5}$',
         logy=True,
         rot=0)

ax.set_xlabel('Recast Class')
ax.set_ylabel('\%')

fig = ax.get_figure();
fig.savefig('images/' + trace + '/classes/classes5.png')


# ##### for base6

# In[60]:

df6 = build_table(classifier6, base6)


# In[61]:

df6


# In[80]:

ax = df6.plot(kind='bar', 
         title='How classes are divided for ' + trace + ' with $p_{rnd} = 10^{-6}$',
         logy=True,
         rot=0)

ax.set_xlabel('Recast Class')
ax.set_ylabel('\%')

fig = ax.get_figure();
fig.savefig('images/' + trace + '/classes/classes6.png')


# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:



